{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "1bd547bd-8894-48bd-9320-c049c204852e",
   "metadata": {},
   "source": [
    "## FINAL PROJECT"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "1db3a5da-a333-4240-b718-4bbd79d1b5a5",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Photo captured and saved as 'captured_photo.jpg'\n"
     ]
    }
   ],
   "source": [
    "import tkinter as tk\n",
    "from tkinter import ttk\n",
    "import cv2\n",
    "from PIL import Image, ImageTk\n",
    "from geopy.geocoders import Nominatim\n",
    "from geopy.distance import geodesic\n",
    "import requests\n",
    "import cohere\n",
    "import webbrowser\n",
    "import boto3\n",
    "import mediapipe as mp\n",
    "import smtplib\n",
    "from email.mime.multipart import MIMEMultipart\n",
    "from email.mime.text import MIMEText\n",
    "\n",
    "\n",
    "# Set up a descriptive user agent\n",
    "USER_AGENT = \"MyLangChainApp/1.0 ((kanchansrivastava8922@gmail.com)\"\n",
    "HEADERS = {'User-Agent': USER_AGENT}\n",
    "\n",
    "# Function to fetch summary from Wikipedia using requests\n",
    "def fetch_wikipedia_summary(query):\n",
    "    url = f\"https://en.wikipedia.org/api/rest_v1/page/summary/{query}\"\n",
    "    response = requests.get(url, headers=HEADERS)\n",
    "    if response.status_code == 200:\n",
    "        data = response.json()\n",
    "        return data.get('extract', \"No summary available.\")\n",
    "    else:\n",
    "        return \"The page does not exist on Wikipedia.\"\n",
    "\n",
    "# Initialize the Cohere language model (replace 'YOUR_COHERE_API_KEY' with your actual Cohere API key)\n",
    "co = cohere.Client('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')\n",
    "\n",
    "# MediaPipe setup for gesture recognition\n",
    "mp_drawing = mp.solutions.drawing_utils\n",
    "mp_drawing_styles = mp.solutions.drawing_styles\n",
    "mp_pose = mp.solutions.pose\n",
    "mp_holistic = mp.solutions.holistic\n",
    "mp_face_detection = mp.solutions.face_detection\n",
    "\n",
    "# Define gesture recognition function\n",
    "def recognize_gesture(landmarks):\n",
    "    if (landmarks[mp_holistic.HandLandmark.THUMB_TIP].y < landmarks[mp_holistic.HandLandmark.WRIST].y and\n",
    "        landmarks[mp_holistic.HandLandmark.INDEX_FINGER_TIP].y < landmarks[mp_holistic.HandLandmark.THUMB_TIP].y):\n",
    "        return \"Thumbs Up\"\n",
    "    elif landmarks[mp_holistic.HandLandmark.WRIST].visibility < 0.9:\n",
    "        return \"Hand Waving\"\n",
    "    elif (landmarks[mp_holistic.HandLandmark.INDEX_FINGER_TIP].y > landmarks[mp_holistic.HandLandmark.MIDDLE_FINGER_TIP].y and\n",
    "          landmarks[mp_holistic.HandLandmark.THUMB_TIP].y > landmarks[mp_holistic.HandLandmark.INDEX_FINGER_TIP].y):\n",
    "        return \"Peace Sign\"\n",
    "    elif landmarks[mp_holistic.HandLandmark.INDEX_FINGER_TIP].visibility > 0.9:\n",
    "        return \"Pointing\"\n",
    "    else:\n",
    "        visible_fingers = sum(1 for lm in landmarks if lm.visibility > 0.9)\n",
    "        return f\"{visible_fingers} Finger(s)\"\n",
    "\n",
    "# Define posture recognition function\n",
    "def recognize_posture(pose_landmarks):\n",
    "    hip_landmarks = [pose_landmarks.landmark[i] for i in [mp_pose.PoseLandmark.LEFT_HIP.value, mp_pose.PoseLandmark.RIGHT_HIP.value]]\n",
    "    if all(hip.y > 0.7 for hip in hip_landmarks):\n",
    "        return \"Sitting\"\n",
    "    else:\n",
    "        return \"Standing\"\n",
    "\n",
    "class GestureRecognitionWindow(tk.Toplevel):\n",
    "    def __init__(self, master):\n",
    "        super().__init__(master)\n",
    "        self.title(\"Gesture Recognition\")\n",
    "\n",
    "        # Start capturing video from webcam\n",
    "        self.cap = cv2.VideoCapture(0)\n",
    "        self.video_label = tk.Label(self)\n",
    "        self.video_label.pack()\n",
    "\n",
    "        self.after(10, self.show_frame)\n",
    "         # Initialize OpenCV camera capture\n",
    "        self.cap = cv2.VideoCapture(0)  # Use 0 for webcam\n",
    "\n",
    "    def show_frame(self):\n",
    "        success, image = self.cap.read()\n",
    "        if success:\n",
    "            with mp_pose.Pose(min_detection_confidence=0.5, min_tracking_confidence=0.5) as pose, \\\n",
    "                 mp_holistic.Holistic(min_detection_confidence=0.5, min_tracking_confidence=0.5) as holistic, \\\n",
    "                 mp_face_detection.FaceDetection(min_detection_confidence=0.5) as face_detection:\n",
    "\n",
    "                image_rgb = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n",
    "                pose_results = pose.process(image_rgb)\n",
    "                holistic_results = holistic.process(image_rgb)\n",
    "                face_results = face_detection.process(image_rgb)\n",
    "\n",
    "                if pose_results.pose_landmarks:\n",
    "                    mp_drawing.draw_landmarks(\n",
    "                        image, pose_results.pose_landmarks, mp_pose.POSE_CONNECTIONS,\n",
    "                        landmark_drawing_spec=mp_drawing_styles.get_default_pose_landmarks_style())\n",
    "                if holistic_results.left_hand_landmarks:\n",
    "                    mp_drawing.draw_landmarks(\n",
    "                        image, holistic_results.left_hand_landmarks, mp_holistic.HAND_CONNECTIONS,\n",
    "                        landmark_drawing_spec=mp_drawing_styles.get_default_hand_landmarks_style())\n",
    "                if holistic_results.right_hand_landmarks:\n",
    "                    mp_drawing.draw_landmarks(\n",
    "                        image, holistic_results.right_hand_landmarks, mp_holistic.HAND_CONNECTIONS,\n",
    "                        landmark_drawing_spec=mp_drawing_styles.get_default_hand_landmarks_style())\n",
    "\n",
    "                if holistic_results.right_hand_landmarks:\n",
    "                    gesture = recognize_gesture(holistic_results.right_hand_landmarks.landmark)\n",
    "                    cv2.putText(image, gesture, (10, 70), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)\n",
    "\n",
    "                if pose_results.pose_landmarks:\n",
    "                    posture = recognize_posture(pose_results.pose_landmarks)\n",
    "                    cv2.putText(image, posture, (10, 100), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)\n",
    "\n",
    "                if face_results.detections:\n",
    "                    num_faces = len(face_results.detections)\n",
    "                    cv2.putText(image, f\"Detected {num_faces} Face(s)\", (10, 130), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2, cv2.LINE_AA)\n",
    "\n",
    "            image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)\n",
    "            img = Image.fromarray(image)\n",
    "            img_tk = ImageTk.PhotoImage(image=img)\n",
    "            self.video_label.img_tk = img_tk\n",
    "            self.video_label.configure(image=img_tk)\n",
    "\n",
    "        self.after(10, self.show_frame)\n",
    "\n",
    "    def __del__(self):\n",
    "        if self.cap.isOpened():\n",
    "            self.cap.release()\n",
    "        super().destroy()\n",
    "\n",
    "class CameraApp:\n",
    "    def __init__(self, root):\n",
    "        self.root = root\n",
    "        self.root.title(\"Camera App\")\n",
    "\n",
    "        # Initialize OpenCV camera capture\n",
    "        self.cap = cv2.VideoCapture(0)  # Use 0 for webcam\n",
    "\n",
    "        # Create a canvas to display the camera feed\n",
    "        self.canvas = tk.Canvas(root, width=640, height=480)\n",
    "        self.canvas.pack()\n",
    "\n",
    "        # Create buttons to switch between filters and capture photo\n",
    "        filter_names = [\"Normal\", \"Grayscale\", \"Sepia\", \"Invert Colors\"]\n",
    "        self.filter_buttons = []\n",
    "        for i, filter_name in enumerate(filter_names):\n",
    "            button = ttk.Button(root, text=filter_name, command=lambda idx=i: self.set_filter(idx))\n",
    "            button.pack(side=tk.LEFT, padx=10, pady=10)\n",
    "            self.filter_buttons.append(button)\n",
    "\n",
    "        self.capture_button = ttk.Button(root, text=\"Capture\", command=self.capture_photo)\n",
    "        self.capture_button.pack(side=tk.RIGHT, padx=10, pady=10)\n",
    "\n",
    "        # Initialize filter index and capture photo flag\n",
    "        self.current_filter = None\n",
    "        self.photo_taken = False\n",
    "\n",
    "        # Start camera loop\n",
    "        self.show_camera_feed()\n",
    "\n",
    "    def show_camera_feed(self):\n",
    "        ret, frame = self.cap.read()\n",
    "        if ret:\n",
    "            # Apply the selected filter\n",
    "            if self.current_filter is not None:\n",
    "                frame = self.apply_filter(frame, self.current_filter)\n",
    "\n",
    "            # Convert frame from BGR to RGB for displaying with Tkinter\n",
    "            frame_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n",
    "\n",
    "            # Resize frame to fit the canvas\n",
    "            frame_resized = cv2.resize(frame_rgb, (640, 480))\n",
    "\n",
    "            # Convert frame to ImageTk format\n",
    "            img = Image.fromarray(frame_resized)\n",
    "            img_tk = ImageTk.PhotoImage(image=img)\n",
    "\n",
    "            # Update canvas with the new frame\n",
    "            self.canvas.img_tk = img_tk  # Keep a reference to prevent garbage collection\n",
    "            self.canvas.create_image(0, 0, anchor=tk.NW, image=img_tk)\n",
    "\n",
    "        # Repeat this method every 10 milliseconds\n",
    "        self.root.after(10, self.show_camera_feed)\n",
    "\n",
    "    def apply_filter(self, frame, filter_idx):\n",
    "        if filter_idx == 1:\n",
    "            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)\n",
    "            frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2BGR)\n",
    "        elif filter_idx == 2:\n",
    "            frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)\n",
    "            frame = cv2.cvtColor(frame, cv2.COLOR_RGB2GRAY)\n",
    "            frame = cv2.cvtColor(frame, cv2.COLOR_GRAY2RGB)\n",
    "        elif filter_idx == 3:\n",
    "            frame = cv2.bitwise_not(frame)\n",
    "        return frame\n",
    "\n",
    "    def set_filter(self, filter_idx):\n",
    "        self.current_filter = filter_idx\n",
    "\n",
    "    def capture_photo(self):\n",
    "        self.photo_taken = True\n",
    "        ret, frame = self.cap.read()\n",
    "        if ret:\n",
    "            # Apply the selected filter\n",
    "            if self.current_filter is not None:\n",
    "                frame = self.apply_filter(frame, self.current_filter)\n",
    "\n",
    "            # Save the captured photo\n",
    "            cv2.imwrite(\"captured_photo.jpg\", frame)\n",
    "            print(\"Photo captured and saved as 'captured_photo.jpg'\")\n",
    "\n",
    "class PlacesWindow(tk.Toplevel):\n",
    "    def __init__(self, master):\n",
    "        super().__init__(master)\n",
    "        self.title(\"Nearby Places Finder\")\n",
    "\n",
    "        # GUI elements for nearby places finder\n",
    "        place_type_label = ttk.Label(self, text=\"Type of Place:\")\n",
    "        place_type_label.pack(pady=10)\n",
    "        self.place_type_var = tk.StringVar()\n",
    "        place_type_entry = ttk.Entry(self, textvariable=self.place_type_var)\n",
    "        place_type_entry.pack(pady=5)\n",
    "\n",
    "        radius_label = ttk.Label(self, text=\"Search Radius (km):\")\n",
    "        radius_label.pack(pady=10)\n",
    "        self.radius_var = tk.DoubleVar()\n",
    "        radius_entry = ttk.Entry(self, textvariable=self.radius_var)\n",
    "        radius_entry.pack(pady=5)\n",
    "\n",
    "        find_places_button = ttk.Button(self, text=\"Find Nearby Places\", command=self.find_and_display_places)\n",
    "        find_places_button.pack(pady=20)\n",
    "\n",
    "        self.result_label = ttk.Label(self, text=\"\")\n",
    "        self.result_label.pack(pady=20)\n",
    "\n",
    "    def find_and_display_places(self):\n",
    "        try:\n",
    "            lat, lon = 26.8467, 80.9462  # Hardcoded latitude and longitude (Kanpur)\n",
    "            place_type = self.place_type_var.get()\n",
    "            search_radius = self.radius_var.get()\n",
    "\n",
    "            geolocator = Nominatim(user_agent=\"nearby_search\")\n",
    "            location = geolocator.reverse((lat, lon))\n",
    "            result_text = f\"\\nYour current location: {location}\\n\"\n",
    "\n",
    "            query = f\"{place_type} near {lat}, {lon}\"\n",
    "            places = geolocator.geocode(query, exactly_one=False, limit=None)\n",
    "            if places:\n",
    "                for place in places:\n",
    "                    place_coords = (place.latitude, place.longitude)\n",
    "                    place_distance = geodesic((lat, lon), place_coords).kilometers\n",
    "                    if place_distance <= search_radius:\n",
    "                        result_text += f\"{place.address} ({place_distance:.2f} km)\\n\"\n",
    "            else:\n",
    "                result_text += \"No nearby places found for the given type.\"\n",
    "\n",
    "            self.result_label.config(text=result_text)\n",
    "        except Exception as e:\n",
    "            self.result_label.config(text=\"Error: Unable to fetch nearby places.\")\n",
    "\n",
    "class EmailWindow(tk.Toplevel):\n",
    "    def __init__(self, master):\n",
    "        super().__init__(master)\n",
    "        self.title(\"Send Email\")\n",
    "         # Initialize OpenCV camera capture\n",
    "        self.cap = cv2.VideoCapture(0)  # Use 0 for webcam\n",
    "\n",
    "        # Create and place widgets for email sending\n",
    "        recipient_label = tk.Label(self, text=\"Recipient:\")\n",
    "        recipient_label.pack()\n",
    "        self.recipient_entry = tk.Entry(self)\n",
    "        self.recipient_entry.pack()\n",
    "\n",
    "        body_label = tk.Label(self, text=\"Body:\")\n",
    "        body_label.pack()\n",
    "        self.body_entry = tk.Entry(self)\n",
    "        self.body_entry.pack()\n",
    "\n",
    "        send_button = tk.Button(self, text=\"Send\", command=self.send_email)\n",
    "        send_button.pack()\n",
    "\n",
    "    def send_email(self):\n",
    "        # Your email details\n",
    "        sender_email = \"srivastavashivansh8922@gmail.com\"\n",
    "        password = \"afwl tgxh mrsb azfm\"\n",
    "\n",
    "        receiver_email = self.recipient_entry.get()\n",
    "        body = self.body_entry.get()\n",
    "\n",
    "        # Setup the MIME\n",
    "        message = MIMEMultipart()\n",
    "        message['From'] = sender_email\n",
    "        message['To'] = receiver_email\n",
    "        message['Subject'] = \"Python Email\"   # Subject of the email\n",
    "\n",
    "        # The body of the email\n",
    "        message.attach(MIMEText(body, 'plain'))\n",
    "\n",
    "        # Use Gmail's SMTP server\n",
    "        server = smtplib.SMTP('smtp.gmail.com', 587)\n",
    "        server.starttls()\n",
    "\n",
    "        # Login to your email account\n",
    "        server.login(sender_email, password)\n",
    "\n",
    "        # Send the email\n",
    "        text = message.as_string()\n",
    "        server.sendmail(sender_email, receiver_email, text)\n",
    "\n",
    "        # Logout and close the connection\n",
    "        server.quit()\n",
    "        # Release the webcam\n",
    "        self.cap.release()\n",
    "        \n",
    "class AWSInstanceWindow(tk.Toplevel):\n",
    "    def __init__(self, master):\n",
    "        super().__init__(master)\n",
    "        self.title(\"AWS Instance Checker\")\n",
    "\n",
    "        # Create a button to check running instances\n",
    "        check_button = tk.Button(self, text=\"Check Instances\", command=self.get_running_instances)\n",
    "        check_button.pack(pady=20)\n",
    "\n",
    "        # Create a label to display the number of running instances\n",
    "        self.label = tk.Label(self, text=\"\")\n",
    "        self.label.pack()\n",
    "\n",
    "    def get_running_instances(self):\n",
    "        try:\n",
    "            # AWS credentials (replace with your own credentials)\n",
    "            aws_access_key_id = 'AKIA2UC27K26F6TQHVK2'\n",
    "            aws_secret_access_key = 'kneg2MWx1cdXVtzqmZyotTGQMwWU3c6JvAuLrKg1'\n",
    "            region_name = 'ap-south-1'  # Change to your region\n",
    "\n",
    "            # Create an EC2 client\n",
    "            ec2_client = boto3.client('ec2', region_name=region_name,\n",
    "                                      aws_access_key_id=aws_access_key_id,\n",
    "                                      aws_secret_access_key=aws_secret_access_key)\n",
    "\n",
    "            # Get the number of running instances\n",
    "            response = ec2_client.describe_instances(\n",
    "                Filters=[{'Name': 'instance-state-name', 'Values': ['running']}])\n",
    "            running_instances_count = sum(len(reservations['Instances']) for reservations in response['Reservations'])\n",
    "\n",
    "            # Update the label text\n",
    "            self.label.config(text=f\"Number of running instances: {running_instances_count}\")\n",
    "        except Exception as e:\n",
    "            self.label.config(text=\"Error: Unable to fetch running instances.\")\n",
    "            \n",
    "class GenerativeAIWindow(tk.Toplevel):\n",
    "    def __init__(self, master):\n",
    "        super().__init__(master)\n",
    "        self.title(\"Generative AI\")\n",
    "\n",
    "        # Create and place widgets for Wikipedia search\n",
    "        query_label = tk.Label(self, text=\"Search Wikipedia:\")\n",
    "        query_label.pack()\n",
    "        self.query_entry = tk.Entry(self)\n",
    "        self.query_entry.pack()\n",
    "\n",
    "        search_button = tk.Button(self, text=\"Search\", command=self.fetch_summary)\n",
    "        search_button.pack()\n",
    "\n",
    "        self.summary_label = tk.Label(self, text=\"\", wraplength=400)\n",
    "        self.summary_label.pack(pady=10)\n",
    "\n",
    "    \n",
    "\n",
    "        self.explanation_label = tk.Label(self, text=\"\", wraplength=400)\n",
    "        self.explanation_label.pack(pady=10)\n",
    "\n",
    "    def fetch_summary(self):\n",
    "        query = self.query_entry.get()\n",
    "        if query:\n",
    "            summary = fetch_wikipedia_summary(query)\n",
    "            self.summary_label.config(text=f\"Summary of {query} from Wikipedia:\\n{summary}\")\n",
    "            self.summary = summary\n",
    "        else:\n",
    "            self.summary_label.config(text=\"Please enter a search query.\")\n",
    "\n",
    "    def generate_explanation(self):\n",
    "        if hasattr(self, 'summary') and self.summary:\n",
    "            response = co.generate(\n",
    "                model='command-xlarge-nightly',\n",
    "                prompt=f\"Provide a detailed explanation based on the following summary from Wikipedia: {self.summary}\",\n",
    "                max_tokens=300\n",
    "            )\n",
    "            self.explanation_label.config(text=response.generations[0].text)\n",
    "        else:\n",
    "            self.explanation_label.config(text=\"Please fetch a summary first.\")\n",
    "\n",
    "class MainWindow(tk.Tk):\n",
    "    def __init__(self):\n",
    "        super().__init__()\n",
    "        self.title(\"Main Window\")\n",
    "\n",
    "        # Create buttons to open different windows\n",
    "        self.open_camera_button = ttk.Button(self, text=\"Camera\", command=self.open_camera_window)\n",
    "        self.open_camera_button.pack(pady=20)\n",
    "\n",
    "        self.open_places_button = ttk.Button(self, text=\"Search Nearby Location\", command=self.open_places_window)\n",
    "        self.open_places_button.pack(pady=20)\n",
    "\n",
    "        self.open_email_button = ttk.Button(self, text=\"Email Send\", command=self.open_email_window)\n",
    "        self.open_email_button.pack(pady=20)\n",
    "\n",
    "        self.open_aws_button = ttk.Button(self, text=\"Check running Intances\", command=self.open_aws_window)\n",
    "        self.open_aws_button.pack(pady=20)\n",
    "\n",
    "        self.open_generative_ai_button = ttk.Button(self, text=\"Search Engine\", command=self.open_generative_ai_window)\n",
    "        self.open_generative_ai_button.pack(pady=20)\n",
    "        \n",
    "        self.open_gesture_recognition_button = ttk.Button(self, text=\"Gesture Recognition\", command=self.open_gesture_recognition_window)\n",
    "        self.open_gesture_recognition_button.pack(pady=20)\n",
    "\n",
    "        self.open_website_button = ttk.Button(self, text=\"My Website\", command=self.open_website)\n",
    "        self.open_website_button.pack(pady=20)\n",
    "        \n",
    "    def open_camera_window(self):\n",
    "        camera_window = tk.Toplevel(self)\n",
    "        CameraApp(camera_window)\n",
    "\n",
    "    def open_places_window(self):\n",
    "        places_window = PlacesWindow(self)\n",
    "\n",
    "    def open_email_window(self):\n",
    "        email_window = EmailWindow(self)\n",
    "\n",
    "    def open_aws_window(self):\n",
    "        aws_window = AWSInstanceWindow(self)\n",
    "\n",
    "    def open_generative_ai_window(self):\n",
    "        generative_ai_window = GenerativeAIWindow(self)\n",
    "        \n",
    "    def open_gesture_recognition_window(self):\n",
    "        gesture_recognition_window = GestureRecognitionWindow(self)\n",
    "\n",
    "    def open_website(self):\n",
    "        # Open a specific website (replace URL with your desired website)\n",
    "        webbrowser.open(\"http://13.201.51.203:1001/\")\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    # Create and run the main application window\n",
    "    root = MainWindow()\n",
    "    root.mainloop()\n"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b9d6bda1-2725-4133-8427-50fb8392fd61",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
